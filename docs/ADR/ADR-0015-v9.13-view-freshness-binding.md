# ADR-0015: v9.13 View Freshness Binding

## Status

Accepted

## Context

Financial execution in QuantumLife operates on *view data* - a snapshot of the user's financial state including balances, payee permissions, provider availability, and shared view agreements. The approval flow works as follows:

1. User requests execution
2. System captures a *view snapshot* at time T1
3. Approvers review and approve based on that snapshot
4. Execution occurs at time T2

**Problem**: If the view changes between T1 and T2, the execution may proceed under conditions different from what approvers reviewed. This creates several risks:

1. **Stale view attacks**: Approving based on old data, executing when conditions have changed
2. **View drift**: Account balances, payee permissions, or provider availability may have changed
3. **Split-brain approval**: In multi-party scenarios, approvers may have seen different view states
4. **Replay with outdated context**: Re-executing an envelope when view has materially changed

Prior v9.x versions bind execution to action hashes and policy snapshots, but do not verify view freshness at execution time.

## Decision

Implement **v9.13: View Freshness Binding** with the following design:

### Core Principles

1. **Read-before-write enforcement**
   - MUST obtain ViewSnapshot BEFORE any provider write
   - ViewSnapshot is fetched via ViewProvider interface at execution time
   - No cached or stale view data permitted

2. **Freshness verification**
   - ViewSnapshot.CapturedAt must be within MaxStaleness of execution time
   - Default MaxStaleness: 5 minutes (300 seconds)
   - Configurable via PolicySnapshot.ViewPolicy.MaxStalenessSeconds

3. **Hash binding**
   - ExecutionEnvelope must carry ViewSnapshotHash computed at approval time
   - At execution, fresh ViewSnapshot hash is computed and compared
   - Mismatch blocks execution (view drift detected)

4. **Multi-party symmetry**
   - ApprovalBundle carries ViewSnapshotHash
   - All approvers must have approved the same view state
   - Bundle.ViewSnapshotHash must match Envelope.ViewSnapshotHash

### ViewSnapshot Structure

```go
type ViewSnapshot struct {
    SnapshotID         string    // Unique identifier
    CapturedAt         time.Time // When snapshot was taken
    CircleID           string    // Requesting circle
    IntersectionID     string    // Shared context (optional)
    PayeeID            string    // Target payee
    Currency           string    // Execution currency
    AmountCents        int64     // Execution amount
    PayeeAllowed       bool      // Payee registry check result
    ProviderID         string    // Selected provider
    ProviderAllowed    bool      // Provider registry check result
    AccountVisibility  []string  // Visible account IDs
    SharedViewHash     string    // Hash of shared view agreement
    BalanceCheckPassed bool      // Sufficient balance indicator
}
```

### Hash Computation

ViewSnapshotHash uses **canonical string serialization** (NOT JSON marshaling):

```go
func ComputeViewSnapshotHash(v ViewSnapshot) ViewSnapshotHash {
    canonical := fmt.Sprintf(
        "snapshot_id:%s|captured_at:%s|circle_id:%s|intersection_id:%s|...",
        v.SnapshotID,
        v.CapturedAt.UTC().Format(time.RFC3339Nano),
        v.CircleID,
        // ... all fields in deterministic order
    )
    hash := sha256.Sum256([]byte(canonical))
    return ViewSnapshotHash(hex.EncodeToString(hash[:]))
}
```

**Rationale**: JSON marshaling is non-deterministic (map ordering, whitespace). Canonical string format ensures identical inputs always produce identical hashes.

### Executor Integration

View freshness verification is Step 2.8 in the executor pipeline:

```
Step 2.7: Verify PolicySnapshotHash
Step 2.8: Verify ViewSnapshotHash (v9.13)
  - Block if ViewSnapshotHash missing from envelope
  - Fetch current ViewSnapshot via ViewProvider
  - Compute fresh hash, compare to envelope hash
  - Block on mismatch (view drift)
  - Check freshness: CapturedAt within MaxStaleness of Now
  - Block if stale
Step 3: Multi-party gate
```

### Multi-Party Gate Integration

Step 1.6 verifies ViewSnapshotHash symmetry:

```
Step 1.5: Verify PolicySnapshotHash symmetry
Step 1.6: Verify ViewSnapshotHash symmetry (v9.13)
  - If both Bundle and Envelope have ViewSnapshotHash
  - They must be identical
  - Block on mismatch (approvers saw different views)
```

### ViewProvider Interface

```go
type ViewProvider interface {
    ProviderID() string
    GetViewSnapshot(ctx context.Context, req ViewSnapshotRequest) (ViewSnapshot, error)
}

type ViewSnapshotRequest struct {
    CircleID       string
    IntersectionID string
    PayeeID        string
    Currency       string
    AmountCents    int64
    ProviderID     string
    Clock          clock.Clock
    TraceID        string
}
```

### Policy Extension

```go
type ViewPolicySnapshot struct {
    MaxStalenessSeconds int // Default: 300 (5 minutes)
}
```

Included in PolicySnapshot for hash binding.

### Audit Events

| Event Type | Description |
|------------|-------------|
| v9.view.snapshot.requested | ViewSnapshot fetch initiated |
| v9.view.snapshot.received | ViewSnapshot received from provider |
| v9.view.freshness.checked | Staleness check performed |
| v9.view.hash.verified | Hash comparison performed (match) |
| v9.view.hash.mismatch | Hash comparison failed (drift detected) |
| v9.execution.blocked.view_stale | Execution blocked - view too old |
| v9.execution.blocked.view_hash_mismatch | Execution blocked - view changed |
| v9.execution.blocked.view_hash_missing | Execution blocked - no hash bound |
| v9.view.snapshot.bound | ViewSnapshot successfully verified |

#### Event Metadata

| Field | Description |
|-------|-------------|
| envelope_id | Execution envelope identifier |
| trace_id | Trace identifier for correlation |
| snapshot_id | ViewSnapshot identifier |
| captured_at | When snapshot was captured |
| staleness_ms | Age of snapshot in milliseconds |
| max_staleness_ms | Configured maximum staleness |
| expected_hash | Hash from envelope (truncated) |
| actual_hash | Hash computed from current view (truncated) |

## Consequences

### Positive

- **Prevents stale view attacks**: Execution only proceeds with fresh view data
- **Detects view drift**: Changes between approval and execution are caught
- **Ensures multi-party consistency**: All approvers approved the same view
- **Deterministic verification**: Hash comparison is reproducible
- **Configurable freshness**: MaxStaleness can be tuned per policy

### Negative

- **Additional latency**: ViewProvider fetch adds round-trip time
- **Tighter execution window**: Must execute within MaxStaleness of approval
- **More blocked executions**: Legitimate executions may be blocked if view changed

### Tradeoffs

1. **Freshness over convenience**: We prefer blocking executions when view changed over allowing potentially incorrect operations.

2. **Strict hash matching**: Any field change (even benign) causes hash mismatch. This is intentional - we cannot determine which changes are "safe" to ignore.

3. **Fixed staleness window**: MaxStaleness is configured at policy level, not per-execution. This simplifies reasoning but may be too strict or too loose for specific cases.

## Compatibility

- Maintains all v9.x constraints (no background execution, no auto-retry, single trace finalization)
- Provider registry (v9.9) and payee registry (v9.10) remain enforced
- Policy snapshot binding (v9.12) integrated with view policy
- Caps and rate limits (v9.11) unchanged
- Multi-party approvals enhanced with view hash symmetry

## Implementation Notes

- ViewSnapshot hash computed using canonical string serialization
- MockViewProvider available for testing with configurable overrides
- SetSnapshotIDOverride and SetCapturedAtOverride enable deterministic tests
- BuildApprovalBundle automatically copies ViewSnapshotHash from envelope
- Guardrail script `view_snapshot_enforced.sh` verifies implementation

### Demo Scenarios

| Scenario | Description | Expected Result |
|----------|-------------|-----------------|
| S1 | Valid view snapshot, fresh, hash matches | Execution succeeds |
| S2 | View captured 10 min ago, MaxStaleness=5 min | Blocked: view stale |
| S3 | View changed between approval and execution | Blocked: hash mismatch |
| S4 | Envelope missing ViewSnapshotHash | Blocked: hash missing |
| S5 | Multi-party with matching view hashes | Execution succeeds |

## References

- QUANTUMLIFE_CANON_V1.md
- CANON_ADDENDUM_V9_FINANCIAL_EXECUTION.md
- TECHNICAL_SPLIT_V9_EXECUTION.md
- ADR-0014-v9.11-caps-and-rate-limits.md
