# ADR-0014: v9.11 Caps and Rate-Limited Execution Ledger

## Status

Accepted

## Context

Financial execution in QuantumLife must prevent:
1. **Slow drain attacks**: Gradual unauthorized money movement through many small transactions
2. **Burst execution patterns**: Large volumes of transactions in short periods
3. **Per-payee concentration**: Excessive payments to single recipients
4. **Intersection abuse**: Exploitation of shared money contexts

Prior v9.x versions enforce pre-execution validation (provider registry, payee registry, approvals, etc.) but lack *ledger-level* enforcement of daily totals and attempt counts.

## Decision

Implement **v9.11: Daily Caps + Rate-Limited Execution Ledger** with the following design:

### Core Principles

1. **Ledger-enforced caps** (not UI-enforced)
   - The caps gate is integrated directly into the executor pipeline
   - UI cannot bypass ledger enforcement
   - Caps apply BEFORE provider Prepare/Execute is invoked

2. **No auto-splitting / no reduce amount**
   - If an amount exceeds remaining cap, execution is BLOCKED entirely
   - No automatic reduction to fit within cap
   - Users must explicitly create smaller payments

3. **Deterministic tracking**
   - Day key derived from injected clock (UTC YYYY-MM-DD)
   - All state updates are synchronous (no goroutines)
   - Counters are per-currency to prevent aggregation errors

### What Counts

| Event | Attempts Counter | Spend Counter |
|-------|-----------------|---------------|
| Execution starts (after preconditions) | +1 | - |
| Payment succeeds (real money) | - | +amount |
| Payment simulated | - | +0 |
| Payment blocked | - | +0 |
| Payment aborted | - | +0 |
| Payment revoked | - | +0 |
| Payment failed | - | +0 |

**Key insight**: Attempt counts increment regardless of outcome (to prevent rate limit bypass via intentional failures). Spend counts only increment when money actually moves.

### Scope Types

- `circle:<CircleID>` - Per-circle daily caps and attempt limits
- `intersection:<IntersectionID>` - Per-intersection daily caps and attempt limits (only when intersection context exists)
- `payee:<PayeeID>` - Per-payee daily caps (prevents concentration)

### Policy Structure

```go
type Policy struct {
    Enabled bool
    PerCircleDailyCapCents map[string]int64       // currency -> cap
    PerIntersectionDailyCapCents map[string]int64  // currency -> cap
    PerPayeeDailyCapCents map[string]int64         // currency -> cap
    MaxAttemptsPerDayCircle int                    // 0 = unlimited
    MaxAttemptsPerDayIntersection int              // 0 = unlimited
    Notes string                                    // audit only
}
```

### Executor Integration

The caps gate is checked at Step 13.5 in the executor pipeline:

```
Step 13: Check expiry
Step 13.5: Check caps and rate limits (v9.11)
  - capsGate.Check() - verify within limits
  - capsGate.OnAttemptStarted() - increment attempt counters
Step 14: Update ledger to prepared
...
[execution happens]
...
Step 20: Finalize
  - capsGate.OnAttemptFinalized() - increment spend if money moved
```

### Audit Events

| Event Type | Description |
|------------|-------------|
| v9.caps.policy.applied | Policy evaluation started |
| v9.caps.checked | Spend cap check passed (per-scope) |
| v9.caps.blocked | Execution blocked by spend cap (per-scope) |
| v9.ratelimit.checked | Rate limit check passed (per-scope) |
| v9.ratelimit.blocked | Execution blocked by rate limit (per-scope) |
| v9.caps.attempt.counted | Attempt counter incremented |
| v9.caps.spend.counted | Spend counter incremented |

#### v9.11.1: Granular Per-Scope Audit Events

Every scope check (circle, intersection, payee) emits its own audit event with full metadata:

| Metadata Field | Description |
|----------------|-------------|
| envelope_id | Execution envelope identifier |
| attempt_id | Unique attempt identifier |
| day_key | UTC day key (YYYY-MM-DD) for reproducibility |
| scope_type | One of: circle, intersection, payee |
| scope_id | The specific scope identifier |
| currency | ISO 4217 currency code (for cap checks) |
| current_value | Current spend cents or attempt count |
| limit_value | Cap cents or max attempts |
| requested_value | Amount requested or 1 for attempts |
| decision | "allowed" or "blocked" |
| reason | Neutral explanation (for blocked events) |

This enables:
- Full audit trail reconstruction
- Per-scope analytics and monitoring
- Deterministic replay of decisions

## Consequences

### Positive

- **Hard limits enforced at ledger level**: Cannot be bypassed by UI or API manipulation
- **Deterministic and auditable**: All decisions based on injected clock, all state changes logged
- **Currency-safe**: No cross-currency aggregation errors
- **Prevents slow drain**: Even many small transactions will eventually hit caps
- **Prevents burst attacks**: Attempt limits block rapid execution patterns

### Negative

- **May block legitimate usage**: Users at cap must wait until next day
- **No partial execution**: An amount exceeding cap fails entirely
- **Slightly slower execution**: Additional gate check before provider call
- **Memory usage**: Counters stored in-memory for current day

### Tradeoffs

1. **Strictness over convenience**: We prefer blocking legitimate usage over allowing abuse. Users can plan payments to stay within caps.

2. **Hard blocks over soft warnings**: Caps are enforced, not advisory. This is intentional - soft limits can be ignored or overridden.

3. **Attempt counting includes failures**: This prevents rate limit bypass via intentional failures but means a series of blocked attempts will consume the daily limit.

## Compatibility

- Maintains all v9.x constraints (no background execution, no auto-retry, single trace finalization)
- Provider registry (v9.9) and payee registry (v9.10) remain enforced
- Idempotency and replay defense (v9.6) unchanged
- Multi-party approvals and presentation gate unchanged

## Implementation Notes

- Store is in-memory, keyed by (dayKey, scopeType, scopeID, currency)
- Attempt deduplication uses (dayKey, scopeType, scopeID, attemptID) set
- No persistence required for demo; production would need durable storage
- PurgeDaysBefore() available for memory management
- Clock injection enables deterministic testing

### v9.11.1 Implementation Details

- `ScopeCheckResult` struct captures per-scope check results
- `Result.ScopeChecks` array populated by gate.Check() for each scope evaluated
- `Result.DayKey` included for audit reproducibility
- Executor iterates `ScopeChecks` to emit typed events (caps vs ratelimit)
- Events emitted via `emitCapsAuditEvents()` helper in executor
- Separation of cap events (`v9.caps.*`) from rate limit events (`v9.ratelimit.*`)

## References

- QUANTUMLIFE_CANON_V1.md
- CANON_ADDENDUM_V9_FINANCIAL_EXECUTION.md
- TECHNICAL_SPLIT_V9_EXECUTION.md
- ADR-0009-v9-execution-technical-split.md
